#!/usr/bin/env python3
"""
ULTRA-OPTIMIZED SEARCH FOR k=114
With modular filtering based on Jamal's SageMath analysis
"""

import os
import math
import sys

# ================= MODULAR FILTERS =================
def should_skip_n_modular(n):
    """
    QUICK modular tests to eliminate impossible n values.
    Based on: 36n^3 - 19 must be divisible by some Î±
    """
    # Eliminate n where (36n^3 - 19) has impossible residue patterns
    
    # Check mod 7 (from your Sage analysis)
    # 36n^3 - 19 mod 7 = n^3 - 5 mod 7 (since 36 â‰¡ 1 mod 7)
    residue = (pow(n, 3, 7) - 5) % 7
    # Only certain residues can be divisors of numbers with divisors
    if residue not in {0, 1, 2, 4}:  # Adjust based on analysis
        return True
    
    # Check mod 13
    residue13 = (36 * pow(n, 3, 13) - 19) % 13
    if residue13 in {2, 5, 6, 7, 8, 11}:  # Unlikely residues
        return True
    
    # Check mod 5
    residue5 = (36 * pow(n, 3, 5) - 19) % 5
    # 36 â‰¡ 1 mod 5, -19 â‰¡ 1 mod 5, so: n^3 + 1 mod 5
    if residue5 == 2:  # 2 is rare for such expressions
        return True
    
    # Based on your analysis: (36n^3 - 19) often prime for many n
    # We can skip n where it's prime AND large (only divisors Â±1, Â±itself)
    if abs(n) > 1000:
        D = 36 * n**3 - 19
        # Quick primality test (not perfect but fast)
        if is_likely_prime(D) and abs(D) > 10**6:
            # Large primes only have trivial divisors
            return True
    
    return False

def is_likely_prime(n):
    """Quick probabilistic primality test."""
    if n < 2:
        return False
    # Check small primes
    small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    for p in small_primes:
        if n % p == 0:
            return n == p
    
    # Fermat test for a few bases
    for a in [2, 3, 5]:
        if pow(a, n-1, n) != 1:
            return False
    return True

# ================= SMART Î± SELECTION =================
def get_promising_alphas(D):
    """
    Return only Î± values likely to work based on factorization patterns.
    From your Sage analysis: Î± tends to be small or of special form.
    """
    alphas = []
    
    # Always check Â±1 (mathematically important)
    alphas.extend([1, -1])
    
    # Check if D is small enough to factor
    if abs(D) < 10**12:
        # Add small divisors (most solutions have small Î±)
        for d in range(2, min(1000, int(abs(D)**0.5) + 1)):
            if D % d == 0:
                alphas.extend([d, -d])
                # Also check the paired divisor
                paired = abs(D) // d
                if paired != d and paired < 10000:
                    alphas.extend([paired, -paired])
    
    # Check special values from your analysis
    special_values = [17, 19, 37, 73, 109, 127]
    for val in special_values:
        if D % val == 0:
            alphas.extend([val, -val])
    
    return list(set(alphas))  # Remove duplicates

# ================= MAIN SEARCH =================
def optimized_search():
    START_N = int(os.getenv('START_N', '-1000000'))
    END_N = int(os.getenv('END_N', '1000000'))
    STEP = int(os.getenv('STEP', '1'))  # Can be 1 for detailed search
    
    print("=" * 70)
    print("ULTRA-OPTIMIZED SEARCH FOR xÂ³+yÂ³+zÂ³=114")
    print("=" * 70)
    print(f"n âˆˆ [{START_N}, {END_N}] step {STEP}")
    print("Using modular filtering and smart Î± selection")
    print("=" * 70)
    
    solutions = 0
    skipped_modular = 0
    total_checked = 0
    
    for n in range(START_N, END_N + 1, STEP):
        # Progress report
        if total_checked % 100000 == 0:
            print(f"Progress: n = {n:,} | Checked: {total_checked:,} | "
                  f"Modular skips: {skipped_modular:,} | Solutions: {solutions}", flush=True)
        
        total_checked += 1
        
        # ===== MODULAR FILTER =====
        if should_skip_n_modular(n):
            skipped_modular += 1
            continue
        
        # ===== COMPUTE D =====
        D = 36 * n**3 - 19
        
        if D == 0:
            continue
        
        # ===== SMART Î± SELECTION =====
        alphas = get_promising_alphas(D)
        
        # Also check Î± = D if not too large (for completeness)
        if abs(D) < 10**9:
            alphas.extend([D, -D])
        
        # ===== CHECK EACH Î± =====
        for Î± in alphas:
            if Î± == 0:
                continue
            
            # Check divisibility
            if D % Î± != 0:
                continue
            
            # Compute discriminant
            discriminant = (Î± + 6*n)**2 + D // Î±
            
            if discriminant < 0:
                continue
            
            # Perfect square check (optimized)
            root = math.isqrt(discriminant)
            if root * root == discriminant:
                x = -Î± + root
                y = 2*Î± + 6*n
                z = -Î± - root
                
                # Final verification
                if x**3 + y**3 + z**3 == 114 and x != 0:
                    solutions += 1
                    
                    print("\n" + "!" * 70)
                    print("ðŸŽ¯ SOLUTION FOUND!")
                    print("!" * 70)
                    print(f"n = {n:,}")
                    print(f"Î± = {Î±:,}")
                    print(f"x = {x:,}")
                    print(f"y = {y:,}")
                    print(f"z = {z:,}")
                    print(f"Verification: {x}Â³ + {y}Â³ + {z}Â³ = 114 âœ“")
                    print("!" * 70 + "\n")
                    
                    # Save to file
                    with open('/app/solutions.txt', 'a') as f:
                        f.write(f"{n},{Î±},{x},{y},{z}\n")
    
    # Final report
    print("\n" + "=" * 70)
    print("SEARCH COMPLETE - OPTIMIZATION REPORT")
    print("=" * 70)
    print(f"Total n values considered: {total_checked:,}")
    print(f"Skipped by modular filter: {skipped_modular:,} ({100*skipped_modular/max(1,total_checked):.1f}%)")
    print(f"Solutions found: {solutions}")
    print("=" * 70)
    
    return solutions

# ================= RUN =================
if __name__ == "__main__":
    found = optimized_search()
    sys.exit(0 if found > 0 else 1)
